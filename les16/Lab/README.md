Концепции модульного и интеграционного тестирования
1. Что такое модульное тестирование и чем оно отличается от интеграционного?
Модульное тестирование:

Определение: Процесс тестирования отдельных компонентов (модулей) программы, таких как методы или классы, в изоляции от остальной системы. Цель — проверить, что каждый модуль работает корректно сам по себе.
Характеристики:
Тестирует небольшой участок кода (например, метод или класс).
Выполняется в изолированной среде, где внешние зависимости (база данных, API, другие сервисы) заменяются заглушками или моками.
Быстрое выполнение, так как не требует настройки сложной инфраструктуры.
Обычно пишется разработчиками для проверки логики кода.



Интеграционное тестирование:

Определение: Процесс тестирования взаимодействия между несколькими компонентами системы (например, сервисами, репозиториями, базами данных) для проверки их совместной работы.
Характеристики:
Тестирует взаимодействие модулей или подсистем.
Требует реальных или эмулированных внешних зависимостей (например, тестовая база данных).
Более медленное выполнение из-за необходимости настройки инфраструктуры.
Проверяет, как компоненты работают вместе в условиях, приближенных к реальным.



Основные отличия:



Аспект
Модульное тестирование
Интеграционное тестирование



Область тестирования
Отдельный модуль (метод, класс)
Взаимодействие между модулями


Зависимости
Изолированы (заглушки, моки)
Реальные или эмулированные (например, H2)


Скорость
Быстрое выполнение
Медленнее из-за инфраструктуры


Цель
Проверка логики модуля
Проверка интеграции компонентов


Кто пишет
Разработчики
Разработчики или QA-инженеры


2. Какие фреймворки чаще всего используются для модульного тестирования в Java?
Наиболее популярные фреймворки для модульного тестирования в Java:

JUnit: 
Самый распространённый фреймворк (версии JUnit 4 и JUnit 5).
Используется для написания и запуска тестов, предоставляет аннотации (@Test, @BeforeEach, @AfterEach) и assertions (assertEquals, assertThrows).


TestNG:
Альтернатива JUnit с дополнительными возможностями, такими как параллельное выполнение тестов и группировка.
Подходит для сложных тестовых сценариев.


Mockito:
Фреймворк для создания моков и заглушек, часто используется в связке с JUnit.
Позволяет симулировать поведение зависимостей (например, @Mock, when(...).thenReturn(...)).


AssertJ:
Библиотека для более выразительных и читаемых assertions (например, assertThat(value).isEqualTo(expected)).
Часто используется с JUnit или TestNG.


Hamcrest:
Библиотека для создания гибких и читаемых проверок (matchers), интегрируется с JUnit.
Пример: assertThat(value, is(equalTo(expected))).



Пример использования: В проекте с build.gradle.kts (как в твоём случае) зависимости для JUnit и Mockito уже настроены:
testImplementation("org.junit.jupiter:junit-jupiter")
testImplementation("org.mockito:mockito-core:5.12.0")

3. Зачем используют заглушки (stubs) и моки (mocks) в тестах?
Заглушки (stubs):

Определение: Объекты, которые предоставляют заранее заданные ответы на вызовы методов, заменяя реальные зависимости.
Цель: 
Обеспечить предсказуемое поведение зависимости для тестирования модуля.
Упростить тестирование, избегая сложной настройки реальных компонентов.


Пример: В OrderServiceTest, заглушка для userRepository.findByUsername("testuser") возвращает объект User:when(userRepository.findByUsername("testuser")).thenReturn(user);



Моки (mocks):

Определение: Объекты, которые не только предоставляют заданные ответы, но и позволяют проверять, были ли вызваны определённые методы с ожидаемыми аргументами.
Цель: 
Проверить взаимодействие тестируемого модуля с зависимостями.
Убедиться, что методы зависимости вызываются корректно (например, количество вызовов).


Пример: В OrderServiceTest, проверка вызова метода saveAndFlush:verify(orderRepository, times(2)).saveAndFlush(any(Order.class));



Зачем нужны:

Изоляция: Устраняют зависимость от внешних систем (база данных, сеть), делая тесты быстрее и надёжнее.
Контроль: Позволяют эмулировать различные сценарии (успех, ошибка, исключение).
Проверка поведения: Моки помогают убедиться, что модуль корректно взаимодействует с зависимостями.

4. Что именно обычно тестируется в модульном тесте?
В модульном тесте проверяется логика отдельного модуля (метода или класса) в изоляции. Обычно тестируются:

Основная функциональность: Корректность выполнения метода для типичных входных данных.
Пример: В OrderServiceTest, проверка, что createOrder создаёт заказ с правильным описанием и продуктами.


Краевые случаи: Поведение метода при нестандартных или граничных входных данных (null, пустые списки, некорректные значения).
Пример: Проверка, что createOrder выбрасывает исключение, если пользователь не найден.


Обработка ошибок: Реакция на исключения или ошибочные состояния.
Пример: Тест createOrder_userNotFound_throwsException проверяет выброс RuntimeException.


Логические ветки: Покрытие всех путей выполнения кода (if/else, циклы).
Пример: Проверка условий в updateOrder для случаев, когда заказ существует или не найден.


Взаимодействие с зависимостями: Проверка, что модуль вызывает методы зависимостей с правильными аргументами (с использованием моков).
Пример: verify(productRepository, times(1)).findById(1L).



Пример из проекта:
@Test
void createOrder_successful() {
    when(userRepository.findByUsername("testuser")).thenReturn(user);
    when(orderRepository.saveAndFlush(any(Order.class))).thenReturn(order);
    when(productRepository.findById(1L)).thenReturn(Optional.of(product));
    orderService.createOrder("Test Order", Arrays.asList(1L), Arrays.asList(2));
    verify(orderRepository, times(2)).saveAndFlush(any(Order.class));
}

5. Как обеспечить изоляцию тестируемого класса от внешних зависимостей?
Изоляция достигается следующими способами:

Использование заглушек и моков:
Фреймворки вроде Mockito создают поддельные объекты для зависимостей.
Пример: В OrderServiceTest, моки для OrderRepository, ProductRepository, и UserRepository заменяют реальные репозитории:@Mock
private OrderRepository orderRepository;




Инъекция зависимостей через конструктор или сеттеры:
Классы проектируются так, чтобы зависимости передавались извне, а не создавались внутри класса.
Пример: OrderService принимает OrderRepository через @Autowired.


Изоляция от внешних систем:
Базы данных, API, или файловые системы заменяются эмуляторами или отключаются.
Пример: Вместо реальной базы данных используется мокированный UserRepository.


Контроль окружения:
Использование аннотаций, таких как @Mock и @InjectMocks в Mockito, для автоматической инъекции моков в тестируемый класс.
Пример:@InjectMocks
private OrderService orderService;




Избежание статических вызовов:
Статические методы или глобальные состояния затрудняют изоляцию, поэтому их заменяют инстанцируемыми объектами или обёртками.



Пример из проекта:
@BeforeEach
void setUp() {
    user = new User();
    user.setUsername("testuser");
    product = new Product();
    product.setId(1L);
    order = new Order();
    order.setId(1L);
    SecurityContextHolder.setContext(securityContext);
    when(securityContext.getAuthentication()).thenReturn(authentication);
    when(authentication.getName()).thenReturn("testuser");
}

6. Можно ли в модульном тесте подключать базу данных? Почему?
Ответ: В модульных тестах не рекомендуется подключать базу данных, так как:

Нарушение изоляции: Модульное тестирование предполагает проверку модуля в отрыве от внешних систем. Подключение базы данных делает тест зависимым от её состояния, конфигурации и доступности.
Скорость: Тесты с базой данных выполняются медленнее из-за операций ввода-вывода.
Сложность настройки: Требуется настройка тестовой базы данных, очистка данных между тестами, что усложняет поддержку.
Ненадёжность: Тесты могут зависеть от внешних факторов (например, сетевые сбои или изменения в данных).

Альтернатива:

Используй моки или заглушки для эмуляции взаимодействия с базой данных.
Пример: В OrderServiceTest, orderRepository.findById мокируется:when(orderRepository.findById(1L)).thenReturn(Optional.of(order));



Исключение: Если тест требует взаимодействия с базой данных, это уже интеграционный тест, а не модульный. Для таких случаев используется тестовая база данных, например H2.
7. Что проверяется при интеграционном тестировании?
Интеграционное тестирование проверяет взаимодействие между компонентами системы, включая:

Корректность интеграции: Убедиться, что модули (например, сервис и репозиторий) работают вместе без ошибок.
Пример: В OrderServiceIntegrationTest, проверяется, что createOrder сохраняет заказ в базе H2.


Сохранение данных: Проверка, что данные корректно сохраняются, обновляются или удаляются в базе данных.
Пример: updateOrder_successful проверяет обновление описания заказа.


Обработка ошибок: Проверка поведения при некорректных данных или сбоях.
Пример: createOrder_invalidProduct_doesNotAddProducts проверяет, что продукты с неверным ID не добавляются.


Конфигурация зависимостей: Убедиться, что Spring корректно инъецирует зависимости (например, @Autowired).
Интеграция с внешними системами: Проверка взаимодействия с базой данных, API, или другими сервисами в условиях, приближенных к реальным.

Пример из проекта:
@Test
void createOrder_successful() {
    orderService.createOrder("Test Order", Arrays.asList(product.getId()), Arrays.asList(2));
    List<Order> orders = orderRepository.findAll();
    assertEquals(1, orders.size());
    assertEquals("Test Order", orders.get(0).getDescription());
}

8. Какие компоненты системы должны быть доступны во время интеграционного теста?
Во время интеграционного теста должны быть доступны:

Тестируемые компоненты: Классы, которые взаимодействуют друг с другом (например, OrderService, OrderRepository).
Реальные или эмулированные зависимости:
База данных: Тестовая база данных, такая как H2, для эмуляции реального хранилища.
Контекст Spring: Необходим для инъекции зависимостей (@Autowired) и управления конфигурацией.
Контекст веб-приложения (для веб-приложений): В твоём проекте WAR используется @WebAppConfiguration для предоставления ServletContext.


Конфигурационные классы: Классы, определяющие бины и настройки (например, ConfigDB, ConfigSecurity, ConfigWeb).
Тестовая инфраструктура:
Фреймворки тестирования (JUnit, Spring Test).
Тестовые конфигурации, такие как application-test.properties для H2.


Эмуляторы внешних систем (при необходимости): Например, WireMock для API или встраиваемые серверы.

Пример из проекта:
@ContextConfiguration(classes = {ConfigDB.class, ConfigSecurity.class, ConfigWeb.class})
@WebAppConfiguration
@Transactional
class OrderServiceIntegrationTest {
    @Autowired
    private OrderService orderService;
    @Autowired
    private OrderRepository orderRepository;
}

9. В чём преимущество использования тестовой (встраиваемой) базы данных, например H2, при интеграционном тестировании?
Преимущества использования H2:

Скорость: H2 работает в памяти, что быстрее, чем подключение к реальной базе данных (например, MySQL).
Изоляция: H2 создаёт временную базу данных для каждого теста, избегая конфликтов данных между тестами.
Простота настройки: Не требует установки внешнего сервера базы данных; достаточно зависимости в build.gradle.kts:testImplementation("com.h2database:h2")


Эмуляция реальной базы: H2 поддерживает SQL и имитирует поведение реальных баз данных, таких как MySQL, что делает тесты реалистичными.
Автоматическое управление: С настройкой spring.jpa.hibernate.ddl-auto=create-drop база создаётся и очищается автоматически.
Портативность: Тесты с H2 работают на любой машине без необходимости настройки внешней базы.

Пример из проекта:
# src/test/resources/application-test.properties
spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=create-drop

10. Как определить, что тест является интеграционным, а не модульным?
Тест является интеграционным, если:

Тестирует взаимодействие компонентов: Проверяет, как модули (например, сервис и репозиторий) работают вместе.
Пример: OrderServiceIntegrationTest проверяет сохранение заказа в H2 через OrderRepository.


Использует реальные или эмулированные зависимости: Например, тестовая база данных (H2) вместо моков.
Требует контекста Spring: Использует аннотации, такие как @ContextConfiguration, @SpringBootTest, или @WebAppConfiguration, для загрузки бинов.
Медленнее модульного теста: Из-за настройки инфраструктуры (база данных, контекст).
Проверяет интеграцию с внешними системами: Например, сохранение данных или вызов API.

Тест является модульным, если:

Тестирует один модуль в изоляции: Проверяет логику метода или класса без реальных зависимостей.
Пример: OrderServiceTest использует моки для OrderRepository.


Использует моки или заглушки: Зависимости эмулируются (например, с помощью Mockito).
Быстро выполняется: Не требует настройки базы данных или контекста.
Не зависит от инфраструктуры: Работает без внешних систем.

Пример из проекта:

Модульный тест (OrderServiceTest):@Test
void createOrder_successful() {
    when(orderRepository.saveAndFlush(any(Order.class))).thenReturn(order);
    orderService.createOrder("Test Order", Arrays.asList(1L), Arrays.asList(2));
}


Интеграционный тест (OrderServiceIntegrationTest):@Test
void createOrder_successful() {
    orderService.createOrder("Test Order", Arrays.asList(product.getId()), Arrays.asList(2));
    List<Order> orders = orderRepository.findAll();
    assertEquals(1, orders.size());
}



